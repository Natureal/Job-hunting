# Database Questions
> 数据库面试题总结

---
## Q：MySQL ACID

- Atomicity（原子性）

- Consistency（一致性）

- Isolation（隔离性）

- Durability（持久性）-> 事务完成后，更新被保存，则不能回滚。

## Q：MySQL不可重复读 & 幻读

- 不可重复读（侧重修改）-> 锁行

- 幻读（侧重新增/删除）-> 锁表

## Q：MySQL中的锁（如：表锁，行锁，共享锁，排它锁，间隙锁）

- 排它锁（写锁，X锁）

会阻塞其他事务的读和协，属于行锁。

- 共享锁（读锁，S锁）

会阻塞其他事务修改表数据，属于行锁。

- 间隙锁

在记录之间的锁。

（1）使用唯一索引来搜索唯一行的语句不需要用间隙锁。

（2）当没有建立索引或建立的是非唯一索引时，会有间隙锁（且，当有多个查询条件时，必有间隙锁）。

- 意向锁（如IS，intention shared locks）

意向锁协议：事务想获取某行的S/X锁，必须现获取IS/IX锁，意向锁之间不互斥，可并行。

- 插入意向锁（Gap locks的一种）

针对insert的锁，多个事务在同一个索引下，当插入位置不同时，不会互相阻塞。

- 临键锁（Next-key locks）

封锁记录本身+索引区间，从而避免幻读。

幻读：某次select操作得到的结果数据无法支持后续的业务操作。

- One more thing

select * from table for update 会加读锁。

select * fron table 则是快照读（Snapshot Read），不会加锁。


**按照数据粒度分：**

-  行锁（记录锁）

开销大，加锁慢，会出现死锁，粒度最小，锁冲突概率低，并发度最高。

- 表锁

开销小，加锁快，不会死锁，粒度最大，锁冲突概率高，并发度低。

- 页锁（MySQL特有）

各项指标处于行锁和表锁之间，会死锁。

## Q：MySQL事务隔离级别

1. 读未提交（read-uncommitted）

可读取未提交的数据（脏读，幻读，不可重复度）。

2. 不可重复读/读提交（read-committed）

不可重复读，幻读。

3. 可重复读（repeatable-read）

MySQL默认的方式，使用MVCC（Multiversion Currency Control）机制，存在幻读。

4. 可串行化（serializable）

Notice: 隔离级别越高，越能保证完整性和一致性，但并发性能越差。

## Q：MySQL索引的实现机制

首先，大部分数据库以及文件系统都采用B/B+树来实现索引。

- **B Tree**

1. 每个非叶子节点最多由m-1个key和m个指针组成。（key升序排序）。

2. 所有叶子节点都在同一层。

- **B+ Tree （MySQL普遍使用）**

与B Tree的区别：

1. 有k个子节点必然会有k个key。

2. 非叶节点仅具有索引功能，与记录有关的信息全部存放在叶子节点中。

3. 所有叶节点构成一个有序链表，可按照key的次序遍历全部记录。

**B+ Tree的优缺点：**

优点：

更省空间（因为非叶节点仅作向导），有更好的空间局部性，更高的缓存命中率，有利于遍历，区间查找，搜索。

缺点：

不像B Tree那样，有些经常访问的数据如果离根较近，则效率比较高。

## Q：死锁的产生，预防和解决

**四个必要条件：**

1. 互斥：一个资源每次只能被一个进程占有。

2. 请求与保持：请求其他资源时，进程会保持自己原先持有的资源。

3. 不可剥夺：资源只能由进程自己主动释放。

4. 循环等待：若干进程首尾相接循环等待资源。

**避免死锁的方法**

1. 破坏请求与保持

（1）一次性申请全部所需的资源。

（2）请求资源前，释放原先保持的资源。

2. 破坏不可抢占

（1）申请资源被拒绝的话，则释放自己持有的资源

（2）根据进程优先级，可以抢占资源。

3. 破坏循环等待

（1）对资源进行线性排序，申请资源时按递增顺序进行。

**解决死锁的方法**

（1）抢占资源

（2）终止/撤销进程

（3）银行家算法
